<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Latest Posts &#8211; Spencer's Blog</title>
<meta name="description" content="Describe this nonsense.">
<meta name="keywords" content="Jekyll, theme, themes, responsive, blog, modern">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Latest Posts">
<meta property="og:description" content="Describe this nonsense.">
<meta property="og:url" content="/page2/">
<meta property="og:site_name" content="Spencer's Blog">





<link rel="canonical" href="/page2/">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Spencer's Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<!-- Webfonts -->
<link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-144x144-precomposed.png">



</head>

<body id="post-index" class="feature">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="/images/avatar.jpg" alt="Spencer Smith photo" class="author-photo">
					<h4>Spencer Smith</h4>
					<p>Cloud Engineer working extensively with Linux, OpenStack, and various automation tools. Fan of OSS.</p>
				</li>
				<li><a href="/about/"><span class="btn btn-inverse">Learn More</span></a></li>
				<li>
					<a href="mailto:robertspencersmith@gmail.com"><i class="fa fa-fw fa-envelope"></i> Email</a>
				</li>
				
				
				
				<li>
					<a href="https://linkedin.com/in/spencersmith23"><i class="fa fa-fw fa-linkedin"></i> LinkedIn</a>
				</li>
				<li>
					<a href="https://github.com/rsmitty"><i class="fa fa-fw fa-github"></i> GitHub</a>
				</li>
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="/posts/">All Posts</a></li>
				<li><a href="/tags/">All Tags</a></li>
			</ul>
		</li>
		
	    
	    <li><a href="/theme-setup/" >Theme Setup</a></li>
	  
	    
	    <li><a href="http://mademistakes.com" target="_blank">External Link</a></li>
	  
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


<div class="entry-header">
  <div class="image-credit">Image source: <a href="http://www.dargadgetz.com/ios-7-abstract-wallpaper-pack-for-iphone-5-and-ipod-touch-retina/">dargadgetz</a></div><!-- /.image-credit -->
  
    <div class="entry-image">
      <img src="/images/abstract-1.jpg" alt="Latest Posts">
    </div><!-- /.entry-image -->
  
  <div class="header-title">
    <div class="header-title-wrap">
      <h1>Spencer's Blog</h1>
      <h2>Latest Posts</h2>
    </div><!-- /.header-title-wrap -->
  </div><!-- /.header-title -->
</div><!-- /.entry-header -->

<div id="main" role="main">
  
<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-06-23T00:00:00-04:00"><a href="/Docker-Machine-and-Openstack/">June 23, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Spencer Smith">Spencer Smith</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~3 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/Docker-Machine-and-Openstack/" rel="bookmark" title="How Do I Docker? - Quick Dev Environments with Docker Machine and Openstack" itemprop="url">How Do I Docker? - Quick Dev Environments with Docker Machine and Openstack</a></h1>
    
  </header>
  <div class="entry-content">
    <p>This post will go into some detail about how to get started with docker-machine. Docker Machine is a really nice tool to aid in deploying docker hosts across any environment. It seems to be quickly becoming the standard for creating dev environments. Today, I’ll go through how to talk to OpenStack with Docker Machine and then deploy a quick container.</p>

<h2 id="install-docker-machine"><strong>Install Docker Machine</strong></h2>

<p>I installed both Docker and Docker Machine with Homebrew. There are several other installation options that you can find in the “Installation” sections <a href="https://docs.docker.com/mac/started/">here</a> and <a href="https://docs.docker.com/machine/">here</a>.</p>

<p>For Homebrew, simply issue this in the terminal:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">brew install docker-machine</code></pre></figure>

<h2 id="prepare-openstack"><strong>Prepare Openstack</strong></h2>

<p>There’s a few things that we need to do on the OpenStack side in order to ensure that our machine can be created successfully. First, go ahead and source your keystone credentials. Docker Machine will use these environment variables if they are present. This keeps us from having to pass a bunch of authentication parameters later on.</p>

<p>Next, take a look at your OpenStack environment. We’ll need to gather up some IDs and ensure some things are setup properly. First, take a look at your security group that you plan to use and ensure that SSH access is allowed into it. It’s also important to note here that you’ll want to allow any ports that you plan to map into your containers. For me, I allowed ports 22 and 80 initially. Now, let’s gather some IDs. I needed to find the ssh user for my image type (Centos 7), the image ID, the flavor I wished to use, the floating-ip pool name, and finally the security group that I wanted to use.</p>

<h2 id="create-our-machine"><strong>Create Our Machine</strong></h2>

<p>We’re finally ready to create our machine. Using the IDs I found above, here is the (extremely verbose) command that I issued:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-machine create --driver openstack<span class="se">\</span>
 --openstack-ssh-user centos<span class="se">\</span>
 --openstack-image-id cfb0a24a-16a5-4d19-a15b-ee29c9375d52<span class="se">\</span>
 --openstack-flavor-name m1.small<span class="se">\</span>
 --openstack-floatingip-pool public<span class="se">\</span>
 --openstack-sec-groups default<span class="se">\</span>
 docker-dev</code></pre></figure>

<p>Be patient here. I found that creating the machine took quite a while, as the docker-machine command will SSH into the instance and do some long-running tasks like ‘yum upgrade’.</p>

<p>Once complete, we’ll want to override our built in docker settings to point to our new machine. We can do that by issuing:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">eval</span> <span class="s2">"</span><span class="k">$(</span>docker-machine env docker-dev<span class="k">)</span><span class="s2">"</span></code></pre></figure>

<p>Finally, we’ll want to ensure that our machine is totally up to date by issuing the following:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-machine upgrade docker-dev</code></pre></figure>

<h2 id="write-a-test-container"><strong>Write A Test Container</strong></h2>

<p>Now that we have a working Docker Machine in OpenStack, let’s try deploying something fun to it. First, we’ll create a Dockerfile to simply install Apache and push a little image and a webpage.</p>

<p>In a test directory, I created three files: Dockerfile, index.html, and logo.png. Here’s the contents of each file:</p>

<p><strong>Dockerfile:</strong></p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">FROM ubuntu:14.04
MAINTAINER Spencer Smith &lt;robertspencersmith@gmail.com&gt;
RUN apt-get update
RUN apt-get install -y apache2
ADD index.html /var/www/html/index.html
ADD logo.png /var/www/html/logo.png
RUN chmod 777 /var/www/html/logo.png</code></pre></figure>

<p><strong>index.html:</strong></p>

<figure class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"logo.png"</span> <span class="na">width=</span><span class="s">"300"</span> <span class="na">height=</span><span class="s">"300"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;h3&gt;</span>Hello, World!<span class="nt">&lt;/h3&gt;</span>
<span class="nt">&lt;/html&gt;</span></code></pre></figure>

<p><strong>logo.png:</strong></p>

<p><a href="/img/posts/2015-06-23-docker-machine-and-openstack/dockermachine.png">
<img src="/img/posts/2015-06-23-docker-machine-and-openstack/dockermachine.png" style="max-width:20%; border:solid 1px;" /></a></p>

<p>Finally, we’ll build our container image. Change into the directory that contains the files we just created and issue docker build. I’m also supplying a tag so that I can easily identify my apache container that I’m building. The docker build command can take a little while to complete, as there’s a lot happening with the update and installation of apache2.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker build -t rsmitty/apache .</code></pre></figure>

<h2 id="test-it-out"><strong>Test It Out</strong></h2>

<p>Now that our image has been created, it’s time to test it out by launching our new container in our machine. We can do that simply by calling the docker run command. Note that we will launch apache in the foreground so that it continues running and keeps our container up.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker run -d -p 80:80 rsmitty/apache /usr/sbin/apache2ctl -D FOREGROUND</code></pre></figure>

<p>Point your browser to the IP address of our machine and see the results!</p>

<p><a href="/img/posts/2015-06-23-docker-machine-and-openstack/container-running.png">
<img src="/img/posts/2015-06-23-docker-machine-and-openstack/container-running.png" style="max-width75%; border:solid 1px;" /></a></p>


  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-03-29T00:00:00-04:00"><a href="/Installing-Docker/">March 29, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Spencer Smith">Spencer Smith</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~1 minute
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/Installing-Docker/" rel="bookmark" title="Installing Docker" itemprop="url">Installing Docker</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Today, I’m going to detail my steps for installing Docker. Docker is an extension of Linux Containers (LXC) and aims to provide an easier to use environment. This will just be a basic install guide and I will write another post soon, once I figure out how to do some more interesting stuff.</p>

<p>Docker and LXC are interesting because you can run several isolated containers directly in userspace on a Linux host. One of the big advantages here is that no hypervisor is required and you don’t need a guest OS like with VMs. This means that containers can be created scarily fast and should be more performant than their VM counterparts. I’ve seen some debate about whether or not containers are as secure as plain VMs, but truthfully haven’t delved too deeply into the details around this. Docker is a project I’ve been following at a high level for a while because of the potential to hook it into Openstack, but I’m just now getting around to actually putting my hands on it.</p>

<h2 id="setup-a-host"><strong>Setup a Host</strong></h2>
<p>Setting up a host for your Docker containers is pretty easy. Docker is able to run on pretty much any environment. I’m going to use Vagrant CentOS 6.5 box, but you can find other install instructions <a href="https://docs.docker.com/installation/#installation">here</a>.</p>

<ul>
  <li>Docker is part of the EPEL repo, so let’s install that with:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">sudo yum -y install epel-release</code></pre></figure>

<ul>
  <li>Once that’s complete, let’s update all or our packages. I found that I couldn’t start the Docker daemon without updating. There’s a device mapper package that has to be a newer version. After doing this, we can simply install Docker with:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">sudo yum -y update
sudo yum -y install docker-io</code></pre></figure>

<ul>
  <li>Start the Docker daemon and configure it to run at boot:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">sudo service docker start
sudo chkconfig docker on</code></pre></figure>

<ul>
  <li>Pull in the CentOS 6 base container. This may take a bit of time depending on your internet connection.</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">sudo docker pull centos:centos6</code></pre></figure>

<ul>
  <li>Now let’s test that it works by asking docker to run a command inside a container. The run command below will create a container, issue the echo command, then shut the container down.</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">sudo docker run centos:centos6 <span class="nb">echo</span> <span class="s2">"Hola, Mundo!"</span></code></pre></figure>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-03-27T00:00:00-04:00"><a href="/Hosting-Git-Repos/">March 27, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Spencer Smith">Spencer Smith</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~1 minute
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/Hosting-Git-Repos/" rel="bookmark" title="Hosting Git Repos" itemprop="url">Hosting Git Repos</a></h1>
    
  </header>
  <div class="entry-content">
    <p>This post will detail how to host git repos on a server that you own. I’ll be covering how to set up your sever-side repo and then how to connect from a remote machine via SSH.</p>

<h2 id="setup-our-server"><strong>Setup Our Server</strong></h2>
<ul>
  <li>First and foremost, we’ll need to install git. This is going to depend on your package manager, but I’m using CentOS right now, so I’ll be issuing</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">sudo yum install -y git</code></pre></figure>

<ul>
  <li>Now we’ll need to add a user to our system for git. Let’s do that and then switch to that user with:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">sudo useradd git
sudo su - git</code></pre></figure>

<ul>
  <li>Now that we are the git user, we can setup the SSH keys that we want to accept by making the authorized keys file and putting the public keys of each user we want to have access in this file. After creating this directory and file, we need to set the permissions on them properly or SSH will complain.</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">mkdir -p ~/.ssh
touch ~/.ssh/authorized_keys
chmod 700 ~/.ssh
chmod 600 ~/.ssh/authorized_keys</code></pre></figure>

<ul>
  <li>Add the desired public SSH keys in authorized keys. You can add several of these if you have a desire for several users to have access to this git repo. Just separate the keys by putting them on a new line. This should look something like:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDHytEnXVEiGKu6XVDh/evJhM5ANngMeRJiizr6jsiOmWyMtuuqtGi/84EDQ54OOwDlBfdC72YjPaYEafyez8fYls7M2L82P2Ka96hFapUWwF9TzxAw1yEkV81Rv2OZWpAdf451UCZPClludtym0DyGwZdMGfVJx8ZNPJ61lwx5ijwWQvY4dhZF0Hjo431c9d1mgOLxu94WJ15PC6CjAI9zh/zddmJMHgClkqTuGWWf/t3e/SZ8AJ5ABUtcjPutUdJBGvPI814eD3+JgE18D6AiHN/uWm0JLYx5P06htqb2Eb6uAsCJjTIDyl+I0bOYRUp8PlYzJALv+x8RxP1R35Wr rsmitty@github.com</code></pre></figure>

<h2 id="create-git-repo"><strong>Create Git Repo</strong></h2>

<ul>
  <li>It’s time to finally create our git repo. Let’s create an easy directory called /git/ and a subdirectory under that for our test project. We need to switch back to our normal user (with sudo ability) to create a directory at the root. You can do that simply by issuing ‘exit’.</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">sudo mkdir -p /git/testproject.git
sudo chown -R git:git /git</code></pre></figure>

<ul>
  <li>Now, back as the git user, initialize the git repo by using the ‘git init’ command inside that directory:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cd</span> /git/testproject.git
git init --bare</code></pre></figure>

<h2 id="test-it-out"><strong>Test It Out</strong></h2>

<ul>
  <li>Back on your local machine, let’s verify that this is actually working for us. This should be as simple as doing a git clone to the proper path on the remote server:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git clone git@GITSERVERNAME:/git/testproject.git</code></pre></figure>

<ul>
  <li>Change into the local testproject directory and create a file for our first commit:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">touch README.md</code></pre></figure>

<ul>
  <li>Let’s add, commit, and push the file up.</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git add README.md
git commit -m <span class="s2">"initial commit"</span>
git push origin master</code></pre></figure>

<p>Now we’ve got a fully functional git repo with a master branch. All ready to go!</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-02-17T00:00:00-05:00"><a href="/Using-rerun/">February 17, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Spencer Smith">Spencer Smith</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~6 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/Using-rerun/" rel="bookmark" title="Using Rerun" itemprop="url">Using Rerun</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Today’s post will go into some detail on getting started with
<a href="https://rerun.github.io/rerun/">Rerun</a>.
Rerun is a tool that’s kind of meant to bridge the gap between having a
bunch of sysadmin scripts and a full-blown configuration management tool.
The truth is that a lot of times, groups have a bunch of bash scripts
that can perform differently on different machines or exist in several different
versions. This makes it hard to ensure that you’re always using the right one,
the right flags are being passed, etc., etc. Rerun sets out to help wrangle your
shell scripts and present them as something super easy to use.</p>

<h2 id="install-rerun"><strong>Install Rerun</strong></h2>
<ul>
  <li>Installing Rerun is really just a ‘git clone’ and then adding a bunch of
variables to your .bash_profile. I rolled it all into a script so it can just be
run (at your own risk). Just issue <code class="highlighter-rouge">chmod +x whatever_you_name.sh</code>,
followed by <code class="highlighter-rouge">./whatever_you_name.sh</code>.</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>

<span class="c">##Checkout Rerun to home directory</span>
<span class="nb">cd</span> <span class="nv">$HOME</span>
git clone git://github.com/rerun/rerun.git

<span class="c">##Append rerun particulars to user profile</span>
cat <span class="sh">&lt;&lt; EOF &gt;&gt; $HOME/.bash_profile
##Begin vars for rerun
export PATH=$PATH:$HOME/rerun
export RERUN_MODULES=$HOME/rerun/modules
[ -r $HOME/rerun/etc/bash_completion.sh ] &amp;&amp; source $HOME/rerun/etc/bash_completion.sh
[ -t 0 ] &amp;&amp; export RERUN_COLOR=true
##End vars for rerun
</span><span class="err">EOF</span></code></pre></figure>

<ul>
  <li>Exit the terminal and restart, then issue <code class="highlighter-rouge">rerun</code> to see if it’s working.
This should give you a list of the modules installed:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Spencers-MBP:~ spencer<span class="nv">$ </span>rerun
Available modules:
  stubbs: <span class="s2">"Simple rerun module builder"</span> - 1.2.2</code></pre></figure>

<h2 id="create-a-module--command"><strong>Create a Module &amp; Command</strong></h2>
<p>Now let’s run through the Rerun <a href="https://github.com/rerun/rerun/wiki/Tutorial">tutorial</a>.
A lot of this part of the post will be a rehashing of that page, with some differences
here and there to keep myself from just copying/pasting and not actually committing this
to memory. We will be creating a waitfor module that simply waits for a variety of different
conditions like ping to be available at a given address, a file to exist, etc..</p>

<ul>
  <li>Rerun uses a module:command type syntax, where module is kind of the general idea
of what you’re trying to do, while command is the specifics. So, let’s use the stubbs
module’s add-module command to create the bones for our waitfor module:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">rerun stubbs:add-module --module waitfor --description <span class="s2">"waits for a condition."</span></code></pre></figure>

<ul>
  <li>Okay, now let’s add a ping command to our waitfor module with</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">rerun stubbs:add-command --module waitfor --command ping --description <span class="s2">"wait for ping response from address"</span></code></pre></figure>

<p><em>Note that this command creates both a script and a test.sh file. script is what
will actually get run, the test file is for us to write a test plan.</em></p>

<ul>
  <li>For ping, we’ll want to add a host and an interval option. Host will
be required, while we will set the interval option with a default and make overriding
that optional.</li>
  <li>Set the required host option:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">rerun stubbs:add-option --option host --description <span class="s2">"host to ping"</span> --module waitfor --command ping --required <span class="nb">true</span> --export <span class="nb">false</span> --default <span class="s1">'""'</span></code></pre></figure>

<ul>
  <li>Set the optional interval option:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">rerun stubbs:add-option --option interval --description <span class="s2">"how long to wait between attempts"</span> --module waitfor --command ping --required <span class="nb">false</span> --export <span class="nb">false</span> --default 30</code></pre></figure>

<ul>
  <li>Let’s make sure our params look right by checking the output with <code class="highlighter-rouge">rerun waitfor</code>.
Rerun gives a pretty easy to read/understand output when you try to figure out what
a module is capable of.</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Spencers-MBP:~ spencer<span class="nv">$ </span>rerun waitfor
Available commands <span class="k">in </span>module, <span class="s2">"waitfor"</span>:
ping: <span class="s2">"wait for ping response from address"</span>
    --host &lt;<span class="s2">""</span>&gt;: <span class="s2">"host to ping"</span>
   <span class="o">[</span> --interval &lt;30&gt;]: <span class="s2">"how long to wait between attempts"</span></code></pre></figure>

<h2 id="implement-the-command"><strong>Implement the Command</strong></h2>
<p>So now we’ve got our command created, but it doesn’t actually do anything. Rerun
can’t read our mind, so it just lays down some basics and it’s up to us to implement
the particulars.</p>

<ul>
  <li>Open the file <code class="highlighter-rouge">~/rerun/modules/waitfor/commands/ping/script</code> for editing.
Scroll down to the bottom, where you will see:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Command implementation</span>
<span class="c"># ----------------------</span>

<span class="c"># - - -</span>
<span class="c"># Put the command implementation here.</span>
<span class="c"># - - -</span></code></pre></figure>

<ul>
  <li>Replace the ‘Put the command implementation here’ with your code. I had to throw
in a -t flag in the ping command to timeout quicker on Mac.
For our ping check, the code will look like:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">## Loop until a single ping packet returns a result string that contains 64.</span>
<span class="c">## 64 is the number of bytes in ping response</span>
<span class="k">until</span> <span class="o">(</span> ping -c 1 -t 1 <span class="nv">$HOST</span> | grep -q ^64 <span class="o">)</span>
<span class="k">do</span>
   <span class="c">##Sleep by our interval if unsuccessful</span>
   sleep <span class="nv">$INTERVAL</span>
   <span class="nb">echo </span>Pinging <span class="nv">$HOST</span>...
<span class="k">done</span>

<span class="c">##Finally return when ping available</span>
<span class="nb">echo</span> <span class="s2">"OK: </span><span class="nv">$HOST</span><span class="s2"> is pingable."</span></code></pre></figure>

<ul>
  <li>Test it out with a call to localhost. This should always return a positive ping.
<code class="highlighter-rouge">rerun waitfor:ping --host localhost --interval 1</code></li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Spencers-MBP:~ spencer<span class="nv">$ </span>rerun waitfor:ping --host localhost --interval 1
OK: localhost is pingable.</code></pre></figure>

<h2 id="write-tests"><strong>Write Tests</strong></h2>
<p>Okay, let’s write the tests for our new command. This will help us ensure it’s working
the right way.</p>

<ul>
  <li>
    <p>Open <code class="highlighter-rouge">~/rerun/modules/waitfor/tests/ping-1-test.sh</code> for editing. Remove the whole
‘it_fails_without_a_real_test’ block.</p>
  </li>
  <li>
    <p>We’ll create two new functions. One will check that the required host is present.
The other will check that localhost responds as expected. These tests are straight
from the wiki tutorial with extra comments to explain what’s actually happening.</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">##Check that the required host is passed in</span>
it_fails_without_required_options<span class="o">()</span> <span class="o">{</span>
    <span class="c">##Make a temp file to write to</span>
    <span class="nv">OUT</span><span class="o">=</span><span class="k">$(</span>mktemp /tmp/waitfor:ping-XXXX<span class="k">)</span>
    <span class="c">##Negate the error of not passing a host with '!'. Write results to outfile.</span>
    <span class="c">##The '2&gt;' param redirects stderr to the outfile</span>
    ! rerun waitfor:ping 2&gt; <span class="nv">$OUT</span>
    <span class="c">##Check that missing text is in outfile</span>
    grep <span class="s1">'missing required option: --host'</span> <span class="nv">$OUT</span>
    <span class="c">##Delete outfile</span>
    rm <span class="nv">$OUT</span>
<span class="o">}</span>
<span class="c">##Check that command works for localhost</span>
it_reaches_localhost<span class="o">()</span> <span class="o">{</span>
    <span class="c">##Make a temp file to write to</span>
    <span class="nv">OUT</span><span class="o">=</span><span class="k">$(</span>mktemp /tmp/waitfor:ping-XXXX<span class="k">)</span>
    <span class="c">##Run with localhost passed as host param</span>
    rerun waitfor:ping --host localhost &gt; <span class="nv">$OUT</span>
    <span class="c">##Ensure proper output is present in outfile</span>
    grep <span class="s1">'OK: localhost is pingable.'</span> <span class="nv">$OUT</span>
    <span class="c">##Delete outfile</span>
    rm <span class="nv">$OUT</span>
<span class="o">}</span></code></pre></figure>

<ul>
  <li>Finally, let’s check that the output of the stubbs:test command to make sure
our tests pass. Issue <code class="highlighter-rouge">rerun stubbs:test --module waitfor --plan ping</code></li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Spencers-MBP:~ spencer<span class="nv">$ </span>rerun stubbs:test --module waitfor --plan ping
<span class="o">=========================================================</span>
 TESTING MODULE: waitfor
<span class="o">=========================================================</span>
ping
  it_fails_without_required_options:               <span class="o">[</span>PASS]
  it_reaches_localhost:                            <span class="o">[</span>PASS]
<span class="o">=========================================================</span>
Tests:    2 | Passed:   2 | Failed:   0</code></pre></figure>

<h2 id="extend-extend-extend"><strong>Extend, Extend, Extend</strong></h2>

<p>Now that we have learned all of the functionality from the official tutorial, it’s time to extend our module to do other things. Consider what the ‘waitfor’ module is for. It is there to wait on things in general, not just ping responses. So let’s extend our module to support another wait use case, waiting for a file to exist.</p>

<ul>
  <li>First let’s add the new command to our module. This is as simple as it was earlier, just pass the proper options as needed:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">rerun stubbs: add-command --module waitfor --command file --description <span class="s2">"Waits for a file to be present on the system"</span></code></pre></figure>

<ul>
  <li>Add options for the filepath we want to check, as well as the interval we want to wait to check:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">rerun stubbs: add-option --option filepath --description <span class="s2">"full path of file to wait for"</span> --module waitfor --command file --required <span class="nb">true</span> --export <span class="nb">false</span> --default <span class="s1">'""'</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">rerun stubbs: add-option --option interval --description <span class="s2">"how long to wait between attempts"</span> --module waitfor --command file --required <span class="nb">false</span> --export <span class="nb">false</span> --default 30</code></pre></figure>

<ul>
  <li>Time to implement the actual logic behind our file checker. You’ll notice that since this command is similar in function to our ping command, a lot of the same logic that we used previously still applies. Here’s the relevant bash from ‘waitfor/commands/file/script’:</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="k">until</span> <span class="o">[</span> -f <span class="s2">"</span><span class="nv">$FILEPATH</span><span class="s2">"</span> <span class="o">]</span>
<span class="k">do</span>
 <span class="c">##Sleep by our interval if unsuccessful</span>
 sleep <span class="nv">$INTERVAL</span>
 <span class="nb">echo</span> <span class="s2">"Checking for file at </span><span class="nv">$FILEPATH</span><span class="s2">"</span>
<span class="k">done</span>

<span class="c">##Finally return when file exists</span>
<span class="nb">echo</span> <span class="s2">"OK: </span><span class="nv">$FILEPATH</span><span class="s2"> now exists."</span> </code></pre></figure>

<ul>
  <li>We can now see this in action by issuing our command, waiting for a few cycles to occur, then touching the file that we want to exist in another terminal. For me, the touch command was simply  touch /tmp/test.txt.</li>
</ul>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Spencers-MBP:~ spencer<span class="nv">$ </span>rerun waitfor: file --filepath <span class="s2">"/tmp/test.txt"</span> --interval 1
Checking <span class="k">for </span>file at /tmp/test.txt
Checking <span class="k">for </span>file at /tmp/test.txt
Checking <span class="k">for </span>file at /tmp/test.txt
Checking <span class="k">for </span>file at /tmp/test.txt
OK: /tmp/test.txt now exists.</code></pre></figure>

<ul>
  <li>Finally, we would want to write some tests around this command to ensure it functions as expected when variables are missing, etc.. This post is getting pretty lengthy, so I will leave that task up to you.</li>
</ul>

<p>And that’s it! I hope you enjoyed this intro to Rerun. It’s a really fun tool to use once you pick up the basics, and it really makes it dead simple to allow other team mates (even those who may not be very adept with bash) to execute scripts in a known, repeatable manner.</p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->

<article class="hentry">
  <header>
    
    <div class="entry-meta">
      <span class="entry-date date published updated"><time datetime="2015-02-15T00:00:00-05:00"><a href="/Configuration-Management-with-CFEngine/">February 15, 2015</a></time></span><span class="author vcard"><span class="fn"><a href="/about/" title="About Spencer Smith">Spencer Smith</a></span></span>
      
      <span class="entry-reading-time">
        <i class="fa fa-clock-o"></i>
        
Reading time ~2 minutes
      </span><!-- /.entry-reading-time -->
      
    </div><!-- /.entry-meta -->
    
      <h1 class="entry-title"><a href="/Configuration-Management-with-CFEngine/" rel="bookmark" title="Installing CFEngine" itemprop="url">Installing CFEngine</a></h1>
    
  </header>
  <div class="entry-content">
    <p>Continuing on my thread of exploring new technologies for my new job, today I’ll
be looking at CFEngine and how we can use it for configuration management. I’ve
used other tools like Chef and Ansible in the past, but CFEngine is a new one
for me. I’ll be installing and configuring a server and some nodes in my home
Openstack lab.</p>

<h2 id="setup-the-server"><strong>Setup the Server</strong></h2>
<p>I’m going to use the instructions for CFEngine enterprise for this tutorial. It
appears to be free for the first 25 nodes, so it will be nice to test against the
version that I may actually have to use at work.</p>

<ul>
  <li>
    <p>Create a server in Openstack and go ahead and SSH in. I had to use a Ubuntu 12.04
LTS image for this. 14.04 LTS returned an error about not being supported. I imagine
that will be fixed in the future.</p>
  </li>
  <li>
    <p>Open the /etc/hosts file for editing and add an entry for the private IP address to
give it a hostname. The script below with fail if <code class="highlighter-rouge">hostname -f</code> doesn’t return
anything. I added this to my hosts file:
<code class="highlighter-rouge">10.0.0.29 cfengine-server.localdomain</code>. You may also have to enter
<code class="highlighter-rouge">sudo hostname cfengine-server.localdomain</code>.</p>
  </li>
  <li>
    <p>Grab the CFEngine install script with
<code class="highlighter-rouge">wget http://s3.amazonaws.com/cfengine.packages/quick-install-cfengine-enterprise.sh</code>.</p>
  </li>
  <li>
    <p>Make it executable with <code class="highlighter-rouge">chmod +x quick-install-cfengine-enterprise.sh</code>.</p>
  </li>
  <li>
    <p>Run the script with sudo rights and pass the hub argument to specify that this
will be a central hub server:
<code class="highlighter-rouge">sudo ./quick-install-cfengine-enterprise.sh hub</code></p>
  </li>
  <li>
    <p>Bootstrap the CFEngine hub with <code class="highlighter-rouge">sudo /var/cfengine/bin/cf-agent --bootstrap 10.0.0.29</code></p>
  </li>
  <li>
    <p>We should now be able to login to the server’s web UI by going to the floating
IP address in a browser. The default login information is admin/admin. <strong>Make sure
your default security group lets port 80 in.</strong>
<a href="/img/posts/2015-02-15-configuration-management-with-cfengine/server-running.png">
<img src="/img/posts/2015-02-15-configuration-management-with-cfengine/server-running.png" style="max-width:100%; border:solid 1px;" /></a></p>
  </li>
</ul>

<h2 id="setup-the-clients"><strong>Setup the Clients</strong></h2>
<p>Now let’s get some clients set up so that we have some systems to actually manage
with our snazzy new server. This process is almost exactly the same as the above,
with the exception of the argument passed to quick-install-cfengine-enterprise.sh.
I won’t copy/paste everything from above, but just follow the same steps and when
you get there, issue this command instead:
<code class="highlighter-rouge">sudo ./quick-install-cfengine-enterprise.sh agent</code></p>

<p>One last possible caveat here. I created a Ubuntu 12.04 image with the CFEngine
client installed and it caused a kernel panic on boot. I’m not sure what was going on,
but using a 14.04 image worked just fine.</p>

<p>Once you get the client setup completed, you should see your new nodes checked in
in the web UI.
<a href="/img/posts/2015-02-15-configuration-management-with-cfengine/nodes-checked-in.png">
  <img src="/img/posts/2015-02-15-configuration-management-with-cfengine/nodes-checked-in.png" style="max-width:100%; border:solid 1px;" /></a></p>

  </div><!-- /.entry-content -->
</article><!-- /.hentry -->



<div class="pagination">
  <ul class="inline-list">
    
    
      
        <li><a href="" class="btn">Previous</a></li>
      
    

    
    
      <li><a href="">1</a></li>
    

    
    

    
    
    

    
      
        <li><strong class="current-page">2</strong></li>
      
    
      
        
        
        
        <li><a href="/page3/">3</a></li>
      
    

    
    

    
      <li><a href="/page4/">4</a></li>
    

    
    
      <li><a href="/page3/" class="btn">Next</a></li>
    
  </ul>
</div>

</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2016 Spencer Smith. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/hpstr-jekyll-theme/" rel="nofollow">HPSTR Theme</a>.</span>
  </footer>
</div><!-- /.footer-wrapper -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>


<!-- Asynchronous Google Analytics snippet -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61400214-1', 'auto');  
  ga('require', 'linkid', 'linkid.js');
  ga('send', 'pageview');
</script>


          

</body>
</html>